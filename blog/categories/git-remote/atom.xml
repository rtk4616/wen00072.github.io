<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Git Remote | My code works, I don't know why.]]></title>
  <link href="http://wen00072.github.io/blog/categories/git-remote/atom.xml" rel="self"/>
  <link href="http://wen00072.github.io/"/>
  <updated>2018-12-12T21:44:50+08:00</updated>
  <id>http://wen00072.github.io/</id>
  <author>
    <name><![CDATA[Wen Liao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[再談 Git Remote]]></title>
    <link href="http://wen00072.github.io/blog/2016/01/24/talk-more-about-git-remote/"/>
    <updated>2016-01-24T20:30:32+08:00</updated>
    <id>http://wen00072.github.io/blog/2016/01/24/talk-more-about-git-remote</id>
    <content type="html"><![CDATA[<ul>
<li>更新：

<ul>
<li>Apr/09/2016：感謝網友柏瑀的告知，修正白字。</li>
</ul>
</li>
</ul>


<p>git remote 是一個常常被忽略的東西，這次就來看看這個指令和對應的觀念吧。</p>

<p>一樣，先講測試環境，避免無法reproduce的問題。</p>

<pre><code class="text">$ lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 14.04.3 LTS
Release:    14.04
Codename:   trusty

$ git --version
git version 2.7.0
</code></pre>

<p>本次介紹目錄如下</p>

<ul>
<li><a href="#gr_gb">背景說明</a></li>
<li><a href="#gr_cmd">git remote指令介紹</a>

<ul>
<li><a href="#gr_cmd_status">查詢remote資訊</a></li>
<li><a href="#gr_cmd_add">新增remote</a></li>
<li><a href="#gr_cmd_fetch">拉remote repository</a></li>
<li><a href="#gr_cmd_push">remote的branch操作</a></li>
<li><a href="#gr_cmd_rm">刪除remote</a></li>
</ul>
</li>
</ul>


<p><a name="gr_gb"></a></p>

<h2>背景說明</h2>

<p>先來問問男人<code>git remote</code>是什麼吧？</p>

<pre><code>GIT-REMOTE(1)                                     Git Manual                                    GIT-REMOTE(1)

NAME
       git-remote - Manage set of tracked repositories
</code></pre>

<p>白話來說，<code>git remote</code>是用來管理<font color="red">多個</font>tracked repositories。（中文難翻，意思是你要追蹤的git repository）。在大部分的情況，<code>git clone</code>下來後只需要和原本clone的遠端互動的話，你只有一個remote，那麼你機乎不會感受到remote的運作，我天生駑鈍，剛開始只是覺得奇怪怎麼有時候後會有個<code>origin</code>跑出來而已。</p>

<p>如果夠幸運（還是不幸？）你不太會需要遇到需要處理remote的情況。不過在github上面，倒是蠻有機會要用到remote，情境如下。</p>

<ul>
<li>你在github上面有帳號，要fork別人的project <code>A</code>，fork來的稱為<code>A+</code></li>
<li>你在<code>A+</code>開發，同時<code>A</code>也在開發</li>
<li><code>A+</code>有需要和<code>A</code>同步，也許是<code>A</code>有新功能，或是你要回饋程式碼總不能回饋和<code>A</code>差異太大的程式碼</li>
</ul>


<p><code>A+</code>和<code>A</code>同步，是remote常用的情境。常用到github直接給<a href="https://help.github.com/articles/configuring-a-remote-for-a-fork/">懶人包</a>。大概描述如下：</p>

<ul>
<li><code>A+</code>加一個remote，URL為<code>A</code>的URL。白話來說，就是<code>A+</code>要track repository <code>A</code>。

<ul>
<li>remote必須給個名字，github的<a href="https://help.github.com/articles/configuring-a-remote-for-a-fork/">懶人包</a>上給的名字叫upstream。</li>
</ul>
</li>
<li>既然加了一個tracked repository，你就可以做

<ul>
<li>拉remote程式碼下來</li>
<li>切換到remote下面的branch</li>
<li><strong>merge remote 的branch</strong></li>
</ul>
</li>
</ul>


<p><a name="gr_cmd"></a></p>

<h2>git remote指令介紹</h2>

<p>在介紹指令之前，先建立示範git repository 以便下面的說明。情境如下</p>

<ol>
<li>建立新的git repository，稱為<code>repo_1</code></li>
<li>clone <code>repo_1</code>到<code>repo_2</code></li>
<li>clone <code>repo_2</code>到<code>repo_3</code></li>
</ol>


<pre><code>$ git init repo_1
Initialized empty Git repository in /tmp/test_remote/repo_1/.git/

$ cd repo_1/
/repo_1$ touch test_file &amp;&amp; git add test_file &amp;&amp; git commit -a -m "init for test"
[master (root-commit) 6847c3c] init for test
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 test_file

$ cd ../

$ git clone --bare repo_1 repo_2 
Cloning into bare repository 'repo_2'...
done.

$ git clone repo_2/ repo_3
Cloning into 'repo_3'...
done.
</code></pre>

<p>關於repo_2的&ndash;bare部份，一言難盡。長話短說，不這樣幹repo_3不能push到repo_2，有興趣可以看<a href="http://stackoverflow.com/questions/2816369/git-push-error-remote-rejected-master-master-branch-is-currently-checked">這邊</a>。</p>

<p>如果你的git repository是clone過來的，一定會有一個預設remote。沒意外的會叫<code>origin</code> <del>(什麼？你的remote叫<code>aosp</code>? 呃太複雜不討論)</del>，接下來你可以對於remote 操作，分別說明如下：</p>

<ul>
<li><a href="#gr_cmd_status">查詢remote資訊</a></li>
<li><a href="#gr_cmd_add">新增remote</a></li>
<li><a href="#gr_cmd_fetch">拉remote repository</a></li>
<li><a href="#gr_cmd_push">remote的branch操作</a></li>
<li><a href="#gr_cmd_rm">刪除remote</a></li>
</ul>


<p><a name="gr_cmd_status"></a></p>

<h2>查詢remote資訊</h2>

<ul>
<li><code>git remote</code>

<ul>
<li>顯示remote名稱</li>
</ul>
</li>
<li><code>git remote -v</code>

<ul>
<li>顯示remote名稱及remote URL</li>
</ul>
</li>
<li><code>git remote show remote名稱</code>

<ul>
<li>顯示<code>remote名稱</code>的詳細資訊</li>
</ul>
</li>
</ul>


<p>直接看範例</p>

<pre><code>$ cd /tmp/test_remote/repo_3

$ git remote
origin

$ git remote -v
origin  /tmp/test_remote/repo_2/ (fetch)
origin  /tmp/test_remote/repo_2/ (push)

$ git remote show origin 
* remote origin
  Fetch URL: /tmp/test_remote/repo_2/
  Push  URL: /tmp/test_remote/repo_2/
  HEAD branch: master
  Remote branch:
    master tracked
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (up to date)
</code></pre>

<p><a name="gr_cmd_add"></a></p>

<h2>新增remote</h2>

<ul>
<li><code>git add remote名稱 remote_repository_URL</code></li>
</ul>


<p>範例如下</p>

<pre><code>$ git remote add upstream /tmp/test_remote/repo_1/

$ git remote -v
origin  /tmp/test_remote/repo_2/ (fetch)
origin  /tmp/test_remote/repo_2/ (push)
upstream    /tmp/test_remote/repo_1/ (fetch)
upstream    /tmp/test_remote/repo_1/ (push)
</code></pre>

<p>新增完畢後，請記得<code>remote_名稱</code>、<code>remote_名稱 remote_branch_名稱</code>或<code>remote_名稱/remote_branch_名稱</code>是你要操作remote的參數。</p>

<p>另外你還可以加入多個remote來場大亂鬥。例如你從<code>A</code> fork <code>A+</code>，也許有人fork 出來的<code>A++</code>有你想要的功能，就可以再把<code>A++</code>加入你<code>A</code> repository的remote。</p>

<p><a name="gr_cmd_fetch"></a></p>

<h2>拉remote repository</h2>

<ul>
<li><code>git fetch remote_名稱</code></li>
<li><code>git pull remote_名稱/remote_branch_名稱</code></li>
</ul>


<p>我們先在<code>repo_1</code>開一個branch稱為<code>br1</code>
&#8220;`
$ cd /tmp/test_remote/repo_1/</p>

<p>$ git checkout -b br1
Switched to a new branch &lsquo;br1&rsquo;</p>

<p>$ touch test_on_branch &amp;&amp; git add test_on_branch &amp;&amp; git commit test_on_branch -m &ldquo;test&rdquo;
[br1 cc7222f] test
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 test_on_branch
&#8220;`</p>

<p>接下來就是範例時間
&#8220;`
$ git fetch upstream
From /tmp/test_remote/repo_1
 * [new branch]      br1        -> upstream/br1
 * [new branch]      master     -> upstream/master</p>

<p>$ ls
test_file</p>

<p>$ git pull upstream br1
From /tmp/test_remote/repo_1
 * branch            br1        -> FETCH_HEAD
Updating 6847c3c..cc7222f
Fast-forward
 test_on_branch | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 test_on_branch</p>

<p>$ ls
test_file  test_on_branch</p>

<p>$ git status
On branch master
Your branch is ahead of &lsquo;origin/master&rsquo; by 1 commit.
  (use &ldquo;git push&rdquo; to publish your local commits)
nothing to commit, working directory clean
<code>``
注意最後的指令，因為我們pull了</code>upstream/br1<code>，所以local多了一個commit。因此訊息中有說你目前repository 比</code>origin/master<code>(你clone的remote/branch)多一個commit。你可以push回</code>origin/master`。</p>

<p><a name="gr_cmd_push"></a></p>

<h2>remote的branch操作</h2>

<p>原則就是命令中有參數會是<code>remote_名稱</code>、<code>remote_名稱 remote_branch_名稱</code>或<code>remote_名稱/remote_branch_名稱</code>。</p>

<ul>
<li>切換
&#8220;`
$ git checkout upstream/br1
Note: checking out &lsquo;upstream/br1&rsquo;.</li>
</ul>


<p>You are in &lsquo;detached HEAD&rsquo; state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.</p>

<p>If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:</p>

<p>  git checkout -b <new-branch-name></p>

<p>HEAD is now at bd026e3&hellip; test
&#8220;`
中間的一堆英文簡單來說是因為git checkout沒特別參數，git只是把HEAD指到命令中的hash而已。如果你要同時在local開一個branch，可以這樣幹：</p>

<pre><code>$ git checkout --track  upstream/br1 
Branch br1 set up to track remote branch br1 from upstream.
Switched to a new branch 'br1'
</code></pre>

<ul>
<li>merge</li>
</ul>


<pre><code># 先在upstream/br1建立新的commit
$ cd /tmp/test_remote/repo_1/

$ touch test1_on_branch &amp;&amp; git add test1_on_branch &amp;&amp; git commit test1_on_branch -m "test1"
[br1 d82612a] test1
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 test1_on_branch

# 切回repo_3
cd /tmp/test_remote/repo_3

# 先fetch
$ git fetch upstream 
remote: Counting objects: 2, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 2 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (2/2), done.
From /tmp/test_remote/repo_1
   bd026e3..d82612a  br1        -&gt; upstream/br1

# 再merge，事實上和git pull upstream br1 一樣效果（默）
$ git merge upstream/br1 
Updating bd026e3..d82612a
Fast-forward
 test1_on_branch | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 test1_on_branch
</code></pre>

<p><a name="gr_cmd_rm"></a></p>

<h2>刪除remote</h2>

<ul>
<li>git remote remove remote名稱</li>
</ul>


<p>範例如下</p>

<pre><code>$ git remote remove upstream 

$ git remote -v
origin  /tmp/test_remote/repo_2 (fetch)
origin  /tmp/test_remote/repo_2 (push)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[談談git Remote]]></title>
    <link href="http://wen00072.github.io/blog/2015/03/06/talk-about-git-remote/"/>
    <updated>2015-03-06T07:15:00+08:00</updated>
    <id>http://wen00072.github.io/blog/2015/03/06/talk-about-git-remote</id>
    <content type="html"><![CDATA[<p>在軟體專案開發常常會需要比對不同的repository。舉例來說，你可能在遠端有一套軟體專案，這個專案是從upstream fork 下來，那麼如果要把upstream 新的功能合併到專案，人肉合併往往是最容易出錯又最沒效率的方式。如果這兩個專案都有git，那麼git remote就是你的救星。針對剛才講的更詳細的use case可以看<a href="https://help.github.com/articles/configuring-a-remote-for-a-fork/">Git Hub的範例</a></p>

<p>直接拿Use case範例，不囉唆。
Demo情境</p>

<ul>
<li>有兩個遠端repositories: repo1, repo2</li>
<li>將repo1 clone下來到local repository，另外一個透過git remote加入到local repository</li>
<li>在local建立一個branch，對應到repo2</li>
<li>merge repo1到repo2

<ul>
<li>要注意的是其實以upstream 情況是剛好相反，一般來說repo1，也就是你clone的才是你要開發的專案。選擇這樣的case單純只是吃飽撐著。</li>
</ul>
</li>
</ul>


<p>詳細行為範例如下</p>

<ul>
<li><a href="#g2_env">建立測試環境</a></li>
<li><a href="#g2_rt_url">新增remote URL</a></li>
<li><a href="#g2_rt_branch">建立對應remote URL的local branch</a></li>
<li><a href="#g2_rt_merge">在local合併兩個Romote Branch</a></li>
<li><a href="#g2_ref">參考資料</a></li>
</ul>


<p><a name="g2_env"></a></p>

<h2>建立測試環境</h2>

<p>產生兩個遠端repositories: repo1, repo2</p>

<h2>repo1</h2>

<pre><code>$ mkdir remote_repo1
$ cd remote_repo1/
$ git init .
Initialized empty Git repository in /tmp/remote_repo1/.git/
$ echo "repo1" &gt; myfile
$ git add myfile 
$ git commit myfile -m "init"
[master (root-commit) 043d3c6] init
 1 file changed, 1 insertion(+)
 create mode 100644 myfile
</code></pre>

<h2>repo2</h2>

<pre><code>$ cd ../
$ mkdir remote_repo2
$ cd remote_repo2/
$ git init .
Initialized empty Git repository in /tmp/remote_repo2/.git/
$ echo "repo2" &gt; myfile
$ git add myfile 
$ git commit myfile -m "init"
[master (root-commit) 5c329bf] init
 1 file changed, 1 insertion(+)
 create mode 100644 myfile
</code></pre>

<h2>看一下目錄架構</h2>

<pre><code>$ cd ../
$ tree remote_repo1 remote_repo2/
remote_repo1
└── myfile
remote_repo2/
└── myfile
</code></pre>

<p><a name="g2_rt_url"></a></p>

<h2>新增remote URL</h2>

<p>就 git clone，沒啥好說</p>

<pre><code>$ git clone remote_repo1/ local_repo
Cloning into 'local_repo'...
done.
$ cd local_repo/
$ git remote -v
origin  /tmp/remote_repo1/ (fetch)
origin  /tmp/remote_repo1/ (push)
</code></pre>

<p><a name="g2_rt_branch"></a></p>

<h2>建立對應remote URL的local branch</h2>

<p>我們用了<code>git remote add 本地如何稱呼remote remote的URL</code></p>

<pre><code>$ git remote add repo2 /tmp/remote_repo2/
$ git remote -v
origin  /tmp/remote_repo1/ (fetch)
origin  /tmp/remote_repo1/ (push)
repo2   /tmp/remote_repo2/ (fetch)
repo2   /tmp/remote_repo2/ (push)
</code></pre>

<p>接下來把remote URL的repository 拉下來
<code>
$ git fetch repo2
warning: no common commits
remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From /tmp/remote_repo2
 * [new branch]      master     -&gt; repo2/master
</code></p>

<p>然後建立一個branch，對應到repo2的master
&#8220;`
$ git checkout -b local_repo2 repo2/master
Branch local_repo2 set up to track remote branch master from repo2.
Switched to a new branch &lsquo;local_repo2&rsquo;</p>

<p>$ git branch -a
* local_repo2
  master
  remotes/origin/HEAD -> origin/master
  remotes/origin/master
  remotes/repo2/master</p>

<p>$ git diff master
diff &ndash;git a/myfile b/myfile
index 464d9cd..27d38ae 100644
 a/myfile
+++ b/myfile
@@ -1 +1 @@
-repo1
+repo2
&#8220;`</p>

<p><a name="g2_rt_merge"></a></p>

<h2>在local合併兩個Romote Branch</h2>

<p>剩下非常直覺，就把兩個local branch merge，整理完衝突收工。</p>

<pre><code>$ git merge master 
Auto-merging myfile
CONFLICT (add/add): Merge conflict in myfile
Automatic merge failed; fix conflicts and then commit the result.

$ git status 
On branch local_repo2
Your branch is up-to-date with 'repo2/master'.
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add &lt;file&gt;..." to mark resolution)

    both added:      myfile

no changes added to commit (use "git add" and/or "git commit -a")

$ cat myfile 
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
repo2
=======
repo1
&gt;&gt;&gt;&gt;&gt;&gt;&gt; master
$ echo shut-up &gt; myfile 

$ git add myfile 

$ git commit -m "Overwrite myfile"
[local_repo2 a76c0a6] Overwrite myfile
</code></pre>

<p><font color="red"/font>請注意這個case不能夠把更動push 回repo2/master 會噴錯誤如下</font></p>

<pre><code>$ git push repo2 
warning: push.default is unset; its implicit value has changed in
Git 2.0 from 'matching' to 'simple'. To squelch this message
and maintain the traditional behavior, use:

  git config --global push.default matching

To squelch this message and adopt the new behavior now, use:

  git config --global push.default simple

When push.default is set to 'matching', git will push local branches
to the remote branches that already exist with the same name.

Since Git 2.0, Git defaults to the more conservative 'simple'
behavior, which only pushes the current branch to the corresponding
remote branch that 'git pull' uses to update the current branch.

See 'git help config' and search for 'push.default' for further information.
(the 'simple' mode was introduced in Git 1.7.11. Use the similar mode
'current' instead of 'simple' if you sometimes use older versions of Git)

fatal: The upstream branch of your current branch does not match
the name of your current branch.  To push to the upstream branch
on the remote, use

    git push repo2 HEAD:master

To push to the branch of the same name on the remote, use

    git push repo2 local_repo2

To choose either option permanently, see push.default in 'git help config'.
</code></pre>

<p>簡單翻譯一下，目前local branch名稱在repo2上面沒有，你要嘛</p>

<ul>
<li>指定push到repo2的master: <code>git push repo2 HEAD:master</code></li>
<li>要嘛指定push local branch到repo2 repository上</li>
</ul>


<p>第一個情況需要bared repository，時間關係有空再談。</p>

<p><a name="g2_ref"></a></p>

<h2>參考資料</h2>

<ul>
<li><a href="http://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes">ProGit: 2.5 Git Basics - Working with Remotes</a></li>
<li><a href="http://git-scm.com/book/en/v2/Git-Branching-Remote-Branches">ProGit: 3.5 Git Branching - Remote Branches</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
